# ==============================================
# VPN ENTERPRISE - PRODUCTION DOCKER COMPOSE
# ==============================================
# Production-ready setup with security hardening

services:
  # ============================================
  # API SERVER (Production)
  # ============================================
  api:
    build:
      context: ../..
      dockerfile: infrastructure/docker/Dockerfile.api
      target: production
    container_name: vpn-api
    restart: always
    env_file:
      - ../../.env.production
      - ./config/app.prod.env
    environment:
      - NODE_ENV=production
      - PORT=5000
      - POSTGRES_HOST=vpn-postgres
      - POSTGRES_PORT=5432
      - POSTGRES_DB=platform_db
      - POSTGRES_USER=platform_admin
      - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
      - REDIS_HOST=vpn-redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD_FILE=/run/secrets/redis_password
    # NOTE: Docker Compose secrets are sometimes mounted root-only inside containers.
    # The API image runs as a non-root user, so bind-mount the same secret files to ensure readability.
    volumes:
      - ./secrets/db_password:/run/secrets/db_password:ro
      - ./secrets/redis_password:/run/secrets/redis_password:ro
      - ./secrets/api_key:/run/secrets/api_key:ro
      - ./secrets/stripe_secret_key:/run/secrets/stripe_secret_key:ro
      - ./secrets/stripe_webhook_secret:/run/secrets/stripe_webhook_secret:ro
    secrets:
      - api_key
      - db_password
      - redis_password
      - stripe_secret_key
      - stripe_webhook_secret
    networks:
      - vpn-network
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:5000/health']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ============================================
  # WEB DASHBOARD (Production)
  # ============================================
  web:
    build:
      context: ../..
      dockerfile: infrastructure/docker/Dockerfile.web
      target: production
      args:
        - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
        - NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY}
    container_name: vpn-web
    restart: always
    env_file:
      - ../../.env.production
      - ./config/app.prod.env
    environment:
      - NODE_ENV=production
      # Used for server-side rendering calls from inside the Docker network.
      - INTERNAL_API_URL=http://api:5000
    networks:
      - vpn-network
    depends_on:
      api:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M
    healthcheck:
      test:
        [
          'CMD',
          'node',
          '-e',
          "const http=require('http');const targets=['127.0.0.1',process.env.HOSTNAME].filter(Boolean);const tryOne=(i)=>{if(i>=targets.length)process.exit(1);const req=http.get('http://'+targets[i]+':3000/',(res)=>process.exit(((res.statusCode||0)<500)?0:1));req.on('error',()=>tryOne(i+1));req.setTimeout(5000,()=>{req.destroy();tryOne(i+1)});};tryOne(0);",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ============================================
  # POSTGRESQL DATABASE (Production)
  # ============================================
  postgres:
    image: postgres:15-alpine
    container_name: vpn-postgres
    restart: always
    env_file:
      - ../../.env.production
      - ./config/app.prod.env
    environment:
      - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
      - POSTGRES_ADMIN_PASSWORD_FILE=/run/secrets/db_password
      - POSTGRES_DB=platform_db
      - POSTGRES_USER=platform_admin
    secrets:
      - db_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres/init-scripts:/docker-entrypoint-initdb.d:ro
      - ../postgres/postgresql.conf:/etc/postgresql/postgresql.conf:ro
      - postgres_backups:/backups
    networks:
      - vpn-network
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 1G
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U platform_admin -d platform_db']
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ============================================
  # PGADMIN4 (Database Administration)
  # ============================================
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: vpn-pgadmin
    restart: always
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_EMAIL:-admin@vpnenterprise.com}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_PASSWORD:-admin}
      - PGADMIN_CONFIG_SERVER_MODE=True
      - PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED=False
      - PGADMIN_LISTEN_PORT=80
      - SCRIPT_NAME=/pgadmin
      - PGADMIN_CONFIG_ENHANCED_COOKIE_PROTECTION=False
      - PGADMIN_CONFIG_SESSION_COOKIE_SECURE=False
      - PGADMIN_CONFIG_CSRF_COOKIE_SECURE=False
    volumes:
      - pgadmin_data:/var/lib/pgadmin
      - ./postgres/servers.json:/pgadmin4/servers.json:ro
    networks:
      - vpn-network
    depends_on:
      postgres:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    healthcheck:
      test: ['CMD', 'wget', '-O', '-', 'http://localhost:80/pgadmin/misc/ping']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ============================================
  # REDIS (Production)
  # ============================================
  redis:
    image: redis:7-alpine
    container_name: vpn-redis
    restart: always
    command:
      [
        'sh',
        '-lc',
        "redis-server --requirepass \"$(tr -d '\\r\\n' < /run/secrets/redis_password)\" --maxmemory 512mb --maxmemory-policy allkeys-lru --appendonly yes",
      ]
    secrets:
      - redis_password
    volumes:
      - redis_data:/data
    networks:
      - vpn-network
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    healthcheck:
      test: ['CMD', 'redis-cli', '--no-auth-warning', 'ping']
      interval: 10s
      timeout: 5s
      retries: 3
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ============================================
  # N8N WORKFLOW AUTOMATION (Production)
  # ============================================
  n8n:
    image: n8nio/n8n:latest
    container_name: vpn-n8n
    # n8n runs as a non-root user by default. On some hosts the bind-mounted secret files
    # are root-only, which causes EACCES. Running as root avoids the restart loop.
    # If you prefer non-root, fix the host secret file permissions/ACLs instead.
    user: '0:0'
    restart: always
    env_file:
      - ../../.env.production
      - ./config/app.prod.env
    environment:
      - N8N_ENCRYPTION_KEY_FILE=/run/secrets/n8n_encryption_key
      - DB_POSTGRESDB_PASSWORD_FILE=/run/secrets/db_password
      # Credentials should be provided via ../../.env.production as:
      #   N8N_BASIC_AUTH_USER=...
      #   N8N_BASIC_AUTH_PASSWORD=...
      - EXECUTIONS_PROCESS=main
      - EXECUTIONS_DATA_SAVE_ON_ERROR=all
      - EXECUTIONS_DATA_SAVE_ON_SUCCESS=all
    # NOTE: Docker Compose "secrets" are implemented differently depending on environment.
    # In some setups they end up root-only inside the container, which breaks n8n (runs non-root).
    # Bind-mounting these two files ensures the container user can read them reliably.
    volumes:
      - n8n_data:/home/node/.n8n
      - ./secrets/n8n_encryption_key:/run/secrets/n8n_encryption_key:ro
      - ./secrets/db_password:/run/secrets/db_password:ro
    networks:
      - vpn-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test:
        [
          'CMD',
          'node',
          '-e',
          "const http=require('http');const port=Number(process.env.N8N_PORT)||5678;let base=(process.env.N8N_PATH||'');while(base.endsWith('/')) base=base.slice(0,-1);const url='http://127.0.0.1:'+port+(base?base:'')+'/healthz';http.get(url,(res)=>process.exit((res.statusCode||0)===200?0:1)).on('error',()=>process.exit(1));",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ============================================
  # PYTHON API - FastAPI AI Service (Production)
  # Multiple workers for high concurrency
  # ============================================
  python-api:
    build:
      context: ../../flask
      dockerfile: Dockerfile
    container_name: vpn-python-api
    restart: always
    env_file:
      - ../../.env.production
      - ./config/app.prod.env
    environment:
      - DB_PASSWORD_FILE=/run/secrets/db_password
      - REDIS_PASSWORD_FILE=/run/secrets/redis_password
      - API_KEY_FILE=/run/secrets/api_key
      - ENVIRONMENT=production
      - API_URL=http://vpn-api:5000
      - WEB_URL=http://vpn-web:3000
      - REDIS_URL=redis://vpn-redis:6379
      - REDIS_HOST=vpn-redis
      - REDIS_PORT=6379
      - N8N_URL=http://vpn-n8n:5678
      - POSTGRES_URL=postgresql://postgres:postgres@vpn-postgres:5432/postgres
      # External AI API Keys (set these in production)
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      - AI_PROVIDER=${AI_PROVIDER:-openai}
      - CACHE_TTL=3600
      - WORKERS=2
    secrets:
      - db_password
      - redis_password
      - api_key
    volumes:
      - python_api_data:/app/data
    networks:
      - vpn-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
      replicas: 1
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:5001/health']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'
  # ============================================
  # NEXUSAI - Chat-to-Code AI Builder (Production)
  # App generation powered by OpenAI/Anthropic - MORE POWERFUL than Cursor/Lovable
  # ============================================
  nexusai:
    build:
      context: ../../apps/nexusAi/chat-to-code-38
      dockerfile: Dockerfile
      args:
        - NODE_ENV=production
    container_name: vpn-nexusai
    restart: always
    environment:
      - NODE_ENV=production
      - VITE_AI_API_URL=https://python-api.chatbuilds.com
      - VITE_MAIN_API_URL=https://chatbuilds.com/api
    networks:
      - vpn-network
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://127.0.0.1:80/']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

  # ============================================
  # NGINX REVERSE PROXY (Production)
  # ============================================
  nginx:
    image: nginx:alpine
    container_name: vpn-nginx
    restart: always
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx/prod/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/prod/conf.d:/etc/nginx/conf.d:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx_logs:/var/log/nginx
    networks:
      - vpn-network
    depends_on:
      - api
      - web
      - python-api
      - n8n
      - pgadmin
      # Optional; enabled via `--profile nexusai`
      # - nexusai
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M
    healthcheck:
      test: ['CMD', 'nginx', '-t']
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'

networks:
  vpn-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  postgres_data:
    driver: local
  postgres_backups:
    driver: local
  pgadmin_data:
    driver: local
  redis_data:
    driver: local
  n8n_data:
    driver: local
  python_api_data:
    driver: local
  nginx_logs:
    driver: local

# ==============================================
# DOCKER SECRETS (Production)
# ==============================================
# Secrets are mounted as files inside containers at /run/secrets/
# In production, use external secrets from secret manager
secrets:
  db_password:
    file: ./secrets/db_password
  redis_password:
    file: ./secrets/redis_password
  n8n_encryption_key:
    file: ./secrets/n8n_encryption_key
  api_key:
    file: ./secrets/api_key
  stripe_secret_key:
    file: ./secrets/stripe_secret_key
  stripe_webhook_secret:
    file: ./secrets/stripe_webhook_secret
